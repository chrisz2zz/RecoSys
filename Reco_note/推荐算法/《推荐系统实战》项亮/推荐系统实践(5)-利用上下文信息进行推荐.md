### 1. 思维导图

- 本篇为《推荐系统实践--项亮》第五章的学习笔记

![](https://blog-1258986886.cos.ap-beijing.myqcloud.com/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0/14-1.png)

### 2. 什么是上下文

- 本章之前提到的推荐系统算法主要集中研究了如何联系用户兴趣和物品，将最符合用户兴趣的物品推荐给用户，但这些算法都忽略了一点，就是用户所处的上下文(context)。这些上下文包括用户访问推荐系统的时间、地点、心情等，对于提高推荐系统的推荐系统是非常重要的。比如，一个卖衣服的推荐系统在冬天和夏天应该给用户推荐不同种类的服装。推荐系统不能因为用户在夏天喜欢过某件T恤，就在冬天也给该用户推荐类似的T恤。

### 3. 时间上下文

#### 3.1 时间效应

- 时间是一种重要的上下文信息，对用户兴趣有着深入而广泛的影响。一般认为，时间信息对用户兴趣的影响表现在以下几个方面。
  - 用户兴趣是变化的
  - 物品也是有生命周期的
  - 季节效应

#### 3.2 系统时间特性分析

- 在给定时间信息后，推荐系统从一个静态系统变成了一个时变的系统，而用户行为数据也变成了时间序列。研究一个时变系统，需要首先研究这个系统的时间特性。包含时间信息的用户行为数据集由一系列三元组构成，其中每个三元组(u,i,t)代表了用户u在时刻t对物品i产生过行为。我们可以研究的时间特性如下：
- **数据集每天独立用户数的增长情况**
- **系统的物品变化情况**：比如**物品的平均在线天数**，如果一个物品在某天被至少一个用户产生过行为，就定义该物品在这一天在线。因此，我们可以通过物品的平均在线天数度量一类物品的生存周期。
- **用户访问情况**：我们可以统计用户的平均活跃天数，同时也可以统计相隔T天来系统的用户的重合度。
- **相隔T天系统物品流行度向量的平均相似度**：取系统中相邻T天的两天，分别计算这两天的物品流行度，从而得到两个流行度向量。然后，计算这两个向量的余弦相似度，如果相似度大，说明系统的物品在相隔T天的时间内没有发生大的变化，从而说明系统的时效 性不强，物品的平均在线时间较长。

#### 3.3 推荐系统的实时性

- 实现推荐系统的实时性除了对用户行为的存取有实时性要求，还要求推荐算法本身具有实时性，而推荐算法本身的实时性意味着:
  - 实时推荐系统不能每天都给所有用户离线计算推荐结果，然后在线展示昨天计算出来的 结果。所以，要求在每个用户访问推荐系统时，都根据用户这个时间点前的行为实时计算推荐列表。
  - 推荐算法需要平衡考虑用户的近期行为和长期行为，即要让推荐列表反应出用户近期行为所体现的兴趣变化，又不能让推荐列表完全受用户近期行为的影响，要保证推荐列表对用户兴趣预测的延续性。

#### 3.4 推荐结果的时间多样性

- 如何在不损失精度的情况下提高推荐结果的时间多样性呢？提高推荐结果的时间多样性需要分两步解决:首先，需要保证推荐系统能够在用户有了新的行为后及时调整推荐结果，使推荐结果**满足用户最近的兴趣**;其次，需要保证推荐系统在用户没有新的行为时也能够经常变化一下结果，具有一定的**时间多样性**。
- 对于第一步，又可以分成两种情况进行分析。第一是从推荐系统的实时性角度分析。有些推荐系统会每天离线生成针对所有用户的推荐结果，然后在线直接将这些结果展示给用户。这种类型的系统显然无法做到在用户有了新行为后及时调整推荐结果。第二，即使是实时推荐系统，由于使用的算法不同，也具有不同的时间多样性。
- 那么，如果用户没有行为，如何保证给用户的推荐结果具有一定的时间多样性呢?一般的思路有以下几种。
  - **在生成推荐结果时加入一定的随机性，比如从推荐列表前20个结果中随机挑选10个结果 展示给用户，或者按照推荐物品的权重采样10个结果展示给用户**
  - **记录用户每天看到的推荐结果，然后在每天给用户进行推荐时，对他前几天看到过很多次的推荐结果进行适当地降权。**
  - **每天给用户使用不同的推荐算法。**

### 4. 时间上下文推荐算法

#### 4.1 最近最热门

![](https://blog-1258986886.cos.ap-beijing.myqcloud.com/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0/14-2.jpg)

#### 4.2 时间上下文相关的ItemCF算法

- 基于物品（item-based）的个性化推荐算法是商用推荐系统中应用最广泛的，从前面几章的讨论可以看到，该算法由两个核心部分构成：
  - 利用用户行为离线计算物品之间的相似度；
  - 根据用户的历史行为和物品相似度矩阵，给用户做在线个性化推荐
- 时间信息在上面两个核心部分中都有重要的应用，这体现在两种时间效应上
  - **物品相似度**：用户在相隔很短的时间内喜欢的物品具有更高相似度。以电影推荐为例， 用户今天看的电影和用户昨天看的电影其相似度在统计意义上应该大于用户今天看的电影和用户一年前看的电影的相似度
  - **在线推荐：**用户近期行为相比用户很久之前的行为，更能体现用户现在的兴趣。因此在预测用户现在的兴趣时，应该加重用户近期行为的权重，优先给用户推荐那些和他近期喜欢的物品相似的物品。

![](https://blog-1258986886.cos.ap-beijing.myqcloud.com/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0/14-3.jpg)

![](https://blog-1258986886.cos.ap-beijing.myqcloud.com/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0/14-4.jpg)

![](https://blog-1258986886.cos.ap-beijing.myqcloud.com/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0/14-5.jpg)

#### 4.3 时间上下文相关的UserCF算法

- 和ItemCF算法一样，UserCF算法同样可以利用时间信息提高预测的准确率。首先，回顾一下前面关于UserCF算法的基本思想：**给用户推荐和他兴趣相似的其他用户喜欢的物品**。从这个基本思想出发，我们可以在以下两个方面利用时间信息改进UserCF算法。
  - 用户兴趣相似度 在第3章的定义中我们知道，两个用户兴趣相似是因为他们喜欢相同的物品，或者对相同的物品产生过行为。但是，**如果两个用户同时喜欢相同的物品，那么 这两个用户应该有更大的兴趣相似度**。比如用户A在2006年对C++感兴趣，在2007年对Java 感兴趣，用户B在2006年对Java感兴趣，2007年对C++感兴趣，而用户C和A一样，在2006 年对C++感兴趣，在2007年对Java感兴趣。那么，根据第3章的定义，用户A和用户B的兴 趣相似度等于用户A和用户C的兴趣相似度。但显然，在实际世界，我们会认为用户A和C 的兴趣相似度要大于用户A和B。
  - 相似兴趣用户的最近行为在找到和当前用户u兴趣相似的一组用户后，这组用户最近的兴趣显然相比这组用户很久之前的兴趣更加接近用户u今天的兴趣。也就是说，**我们应该给用户推荐和他兴趣相似的用户最近喜欢的物品**。

![](https://blog-1258986886.cos.ap-beijing.myqcloud.com/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0/14-6.jpg)

![](https://blog-1258986886.cos.ap-beijing.myqcloud.com/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0/14-7.jpg)

![](https://blog-1258986886.cos.ap-beijing.myqcloud.com/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0/14-8.jpg)

#### 4.4 时间段图模型

![](https://blog-1258986886.cos.ap-beijing.myqcloud.com/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0/14-9.jpg)

![](https://blog-1258986886.cos.ap-beijing.myqcloud.com/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0/14-10.jpg)

### 5. 地点上下文

- 除了时间，地点作为一种重要的空间特征，也是一种重要的上下文信息。不同地区的用户兴趣 有所不同，用户到了不同的地方，兴趣也会有所不同。在中关村逛街逛累了，希望寻找美食时，你可能会考虑几个因素，包括距离、价位、口味和口碑，而在这些因素里，最重要的因素可能是距离。 因此，很多基于位置的服务（LBS）软件都提供了推荐附近餐馆和商店的功能。